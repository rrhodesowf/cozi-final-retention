# %python
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# ------------------------------------------------------------
# Combined retention visuals (IOS + ANDROID + STRIPE) using IOS-style formatting
#   - IOS updated_logic: cohort_year = first_start_date year (Apple provider)
#   - STRIPE updated_logic: cohort_year = first_start_date year (Stripe provider, WEB platform)
#   - ANDROID updated_logic: cohort_year = paid_cohort_date year (trial->paid adjusted)
# ------------------------------------------------------------

SHOW_TABLES = False   # set True if you also want the matrices printed as tables
INCLUDE_ALL_ROLLUP = True  # add an "ALL" combined heatmap (sums user_cnt across sources)

# Optional plot range override (leave None to auto-range from data)
MIN_YEAR = None
MAX_YEAR = None

sql = """
WITH
/* =========================
   IOS (Apple provider)
   ========================= */
ios_base AS (
  SELECT
    account_id,
    subscription_id,
    sub_iteration,
    CAST(original_sub_begin_date AS DATE) AS original_sub_begin_date,
    CAST(sub_begin_month        AS DATE) AS sub_begin_month
  FROM op
  WHERE UPPER(conversion_platform) = 'IOS'
    AND currency_code = 'USD'
    AND sub_status IN ('active','canceled')
    AND periodicity IN ('month','year')
    AND subscription_id IS NOT NULL
    AND original_sub_begin_date IS NOT NULL
    AND sub_begin_month IS NOT NULL
    AND provider_name IS NOT NULL
    AND LOWER(provider_name) LIKE '%apple%'
),
ios_with_first AS (
  SELECT
    b.*,
    MIN(CASE WHEN b.sub_iteration = 1 THEN b.original_sub_begin_date END)
      OVER (PARTITION BY b.account_id) AS first_start_date
  FROM ios_base b
),

/* =========================
   STRIPE (WEB + Stripe provider)
   ========================= */
stripe_base AS (
  SELECT
    account_id,
    subscription_id,
    sub_iteration,
    CAST(original_sub_begin_date AS DATE) AS original_sub_begin_date,
    CAST(sub_begin_month        AS DATE) AS sub_begin_month
  FROM op
  WHERE UPPER(conversion_platform) = 'WEB'
    AND sub_status IN ('active','canceled')
    AND periodicity IN ('month','year')
    AND subscription_id IS NOT NULL
    AND original_sub_begin_date IS NOT NULL
    AND sub_begin_month IS NOT NULL
    AND provider_name IS NOT NULL
    AND LOWER(provider_name) LIKE '%stripe%'
),
stripe_with_first AS (
  SELECT
    b.*,
    MIN(CASE WHEN b.sub_iteration = 1 THEN b.original_sub_begin_date END)
      OVER (PARTITION BY b.account_id) AS first_start_date
  FROM stripe_base b
),

/* =========================
   ANDROID (trial -> paid adjusted)
   ========================= */
android_base AS (
  SELECT
    account_id,
    subscription_id,
    CAST(original_sub_begin_date AS DATE) AS original_sub_begin_date,
    CAST(sub_begin_month        AS DATE) AS sub_begin_month
  FROM op
  WHERE UPPER(conversion_platform) = 'ANDROID'
    AND currency_code = 'USD'
    AND sub_status IN ('active','canceled')
    AND periodicity IN ('month','year')
    AND account_id IS NOT NULL
    AND subscription_id IS NOT NULL
    AND original_sub_begin_date IS NOT NULL
    AND sub_begin_month IS NOT NULL
),
android_subs AS (
  SELECT DISTINCT subscription_id
  FROM android_base
),
android_events AS (
  SELECT
    se.subscription_id,
    CAST(COALESCE(se.raw_subscription_timestamp, se.raw_event_timestamp) AS TIMESTAMP) AS evt_ts,
    CAST(
      COALESCE(
        se.raw_subscription:paymentState,
        CAST(get_json_object(CAST(se.raw_subscription AS STRING), '$.paymentState') AS INT)
      ) AS INT
    ) AS payment_state
  FROM unity_catalog.cozi_payments.subscription_events se
  INNER JOIN android_subs s
    ON se.subscription_id = s.subscription_id
  WHERE se.subscription_id IS NOT NULL
),
android_events_ranked AS (
  SELECT
    subscription_id,
    evt_ts,
    payment_state,
    ROW_NUMBER() OVER (PARTITION BY subscription_id ORDER BY evt_ts) AS rn
  FROM android_events
  WHERE evt_ts IS NOT NULL
    AND payment_state IS NOT NULL
),
android_flags AS (
  SELECT
    subscription_id,
    MAX(CASE WHEN rn = 1 THEN payment_state END) AS first_payment_state,
    MIN(CASE WHEN payment_state = 1 THEN evt_ts END) AS first_paid_ts
  FROM android_events_ranked
  GROUP BY 1
),
android_enriched AS (
  SELECT
    o.*,
    f.first_payment_state,
    f.first_paid_ts,
    CASE WHEN f.first_payment_state = 2 THEN 1 ELSE 0 END AS is_trial_start,
    CASE WHEN f.first_payment_state = 2 AND f.first_paid_ts IS NULL THEN 1 ELSE 0 END AS is_trial_only,
    CASE
      WHEN f.first_payment_state = 2 THEN CAST(f.first_paid_ts AS DATE)
      ELSE o.original_sub_begin_date
    END AS paid_cohort_date
  FROM android_base o
  LEFT JOIN android_flags f
    ON o.subscription_id = f.subscription_id
),
android_paid_adjusted AS (
  SELECT *
  FROM android_enriched
  WHERE is_trial_only = 0
    AND (
      is_trial_start = 0
      OR (
        paid_cohort_date IS NOT NULL
        AND sub_begin_month >= TRUNC(paid_cohort_date, 'month')
      )
    )
),

/* =========================
   AGGREGATION (same shape as IOS script)
   ========================= */
agg AS (
  -- IOS
  SELECT
    'IOS' AS source,
    'tableau_current' AS cohort_def,
    YEAR(original_sub_begin_date) AS cohort_year,
    YEAR(sub_begin_month)         AS activity_year,
    COUNT(DISTINCT account_id)    AS user_cnt
  FROM ios_with_first
  GROUP BY 1,2,3,4

  UNION ALL

  SELECT
    'IOS' AS source,
    'updated_logic' AS cohort_def,
    YEAR(first_start_date) AS cohort_year,
    YEAR(sub_begin_month)  AS activity_year,
    COUNT(DISTINCT account_id) AS user_cnt
  FROM ios_with_first
  WHERE first_start_date IS NOT NULL
  GROUP BY 1,2,3,4

  -- STRIPE
  UNION ALL

  SELECT
    'STRIPE' AS source,
    'tableau_current' AS cohort_def,
    YEAR(original_sub_begin_date) AS cohort_year,
    YEAR(sub_begin_month)         AS activity_year,
    COUNT(DISTINCT account_id)    AS user_cnt
  FROM stripe_with_first
  GROUP BY 1,2,3,4

  UNION ALL

  SELECT
    'STRIPE' AS source,
    'updated_logic' AS cohort_def,
    YEAR(first_start_date) AS cohort_year,
    YEAR(sub_begin_month)  AS activity_year,
    COUNT(DISTINCT account_id) AS user_cnt
  FROM stripe_with_first
  WHERE first_start_date IS NOT NULL
  GROUP BY 1,2,3,4

  -- ANDROID
  UNION ALL

  SELECT
    'ANDROID' AS source,
    'tableau_current' AS cohort_def,
    YEAR(original_sub_begin_date) AS cohort_year,
    YEAR(sub_begin_month)         AS activity_year,
    COUNT(DISTINCT account_id)    AS user_cnt
  FROM android_base
  GROUP BY 1,2,3,4

  UNION ALL

  SELECT
    'ANDROID' AS source,
    'updated_logic' AS cohort_def,
    YEAR(paid_cohort_date) AS cohort_year,
    YEAR(sub_begin_month)  AS activity_year,
    COUNT(DISTINCT account_id) AS user_cnt
  FROM android_paid_adjusted
  WHERE paid_cohort_date IS NOT NULL
  GROUP BY 1,2,3,4
)
SELECT *
FROM agg
WHERE cohort_year IS NOT NULL AND activity_year IS NOT NULL
"""

spark_df = spark.sql(sql)
df = spark_df.toPandas()

# ---- Optional "ALL sources combined" rollup (single heatmap per cohort_def)
if INCLUDE_ALL_ROLLUP and not df.empty:
    df_all = (
        df.groupby(["cohort_def", "cohort_year", "activity_year"], as_index=False)["user_cnt"]
          .sum()
    )
    df_all["source"] = "ALL"
    df = pd.concat([df, df_all[["source","cohort_def","cohort_year","activity_year","user_cnt"]]], ignore_index=True)

# ---- Normalize dtypes
if df.empty:
    print("No data returned. Check op filters / provider filters / dates.")
else:
    df["cohort_year"] = df["cohort_year"].astype(int)
    df["activity_year"] = df["activity_year"].astype(int)
    df["user_cnt"] = pd.to_numeric(df["user_cnt"], errors="coerce").fillna(0).astype(int)

# ---- Determine plot year range (IOS-style, shared across ALL sources to keep alignment)
if not df.empty:
    if MIN_YEAR is None:
        MIN_YEAR = int(min(df["cohort_year"].min(), df["activity_year"].min()))
    if MAX_YEAR is None:
        MAX_YEAR = int(max(df["cohort_year"].max(), df["activity_year"].max()))
    years = list(range(MIN_YEAR, MAX_YEAR + 1))

def build_matrix(df_sub: pd.DataFrame) -> pd.DataFrame:
    mat = (
        df_sub.pivot_table(
            index="cohort_year",
            columns="activity_year",
            values="user_cnt",
            aggfunc="sum",
            fill_value=0
        )
        .reindex(index=years, columns=years, fill_value=0)
        .astype(float)
    )
    # blank below diagonal for Tableau-like readability
    row_years = np.array(mat.index)
    col_years = np.array(mat.columns)
    return mat.where(col_years[None, :] >= row_years[:, None], np.nan)

def retention_from_matrix(mat: pd.DataFrame) -> pd.DataFrame:
    diag = pd.Series({y: (mat.at[y, y] if (y in mat.index and y in mat.columns) else np.nan) for y in mat.index})
    diag = diag.replace({0: np.nan})
    return mat.div(diag, axis=0)

def display_matrix_as_table(mat: pd.DataFrame, title: str, is_percent: bool=False):
    if is_percent:
        tbl = (mat * 100.0).copy()
        tbl = tbl.applymap(lambda x: "" if pd.isna(x) else f"{x:,.2f}%")
    else:
        tbl = mat.copy()
        tbl = tbl.applymap(lambda x: "" if pd.isna(x) else f"{int(x):,}")
    print(title)
    try:
        display(tbl)
    except NameError:
        print(tbl)

def plot_heatmap(mat: pd.DataFrame, title: str, vmin=None, vmax=None):
    data = np.ma.masked_invalid(mat.values)
    fig, ax = plt.subplots(figsize=(14, 6))
    im = ax.imshow(data, aspect="auto", interpolation="nearest", vmin=vmin, vmax=vmax)
    ax.set_title(title)

    ax.set_xticks(np.arange(len(mat.columns)))
    ax.set_xticklabels(mat.columns, rotation=90)
    ax.set_yticks(np.arange(len(mat.index)))
    ax.set_yticklabels(mat.index)

    plt.colorbar(im, ax=ax)
    plt.tight_layout()
    plt.show()

# ---- Visuals (IOS-style loop + formatting)
sources = ["IOS", "ANDROID", "STRIPE"] + (["ALL"] if INCLUDE_ALL_ROLLUP else [])
cohort_defs = ["tableau_current", "updated_logic"]

for source in sources:
    for cohort_def in cohort_defs:
        df_sub = df[(df["source"] == source) & (df["cohort_def"] == cohort_def)].copy()
        if df_sub.empty:
            print(f"No data for source={source}, cohort_def={cohort_def}")
            continue

        user_mat = build_matrix(df_sub)
        ret_mat  = retention_from_matrix(user_mat)

        if SHOW_TABLES:
            display_matrix_as_table(user_mat, f"{source} | {cohort_def} | User Count")
            display_matrix_as_table(ret_mat,  f"{source} | {cohort_def} | Retention Rate", is_percent=True)

        plot_heatmap(ret_mat, f"{source} | {cohort_def} | Retention Rate Heatmap", vmin=0, vmax=1)
